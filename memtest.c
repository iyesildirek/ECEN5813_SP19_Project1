/*****************************************************************************
* Copyright (C) 2019 by Ismail Yesildirek & Bijan Kianian
*
* Redistribution, modification or use of this software in source or binary
* forms is permitted as long as the files maintain this copyright. Users are
* permitted to modify this and use it to learn about the field of embedded
* software. Ismail Yesildirek, Bijan Kianian, and the University of Colorado are not
* liable for any misuse of this material.
*
*****************************************************************************/
/**
* @file memtest.c
* @brief This source file contains a c program to manipulate and test memory.
*
* @author Ismail Yesildirek & Bijan Kianian
* @date February 23 2019
* @version 1.3
*
*/

#include "memtest.h"

int memoryOffsetValue = 0;        /* Offset value for the memory block to be allocated*/
int* Block_Address = NULL;            /* Place holder for block address*/
int allocStatus = 0;	//Flag 

int main()
{
	printf("This is a simple program for testing memory.\n");
	printf("Type 'help' for more details or 'exit' to leave the program: \n");

	int validStatus = 0;

	while (validStatus == 0)
	{
		validStatus = inputCheck();
	}

	return 0;
}
/*########################################## inputCheck() Start #######################################################*/
int inputCheck(void)
{
	char *cmds[] = { "help", "exit", "allocate", "free", "display", "write" };         /* Constant strings to be compared with user input commands */
	char *Token[10];               /* Array of strings for saving tokens in command line after parsing user input line*/
	char userInput[50], temp;            /* Array to store input command line string */
	//int KB_Input=0;                  /* Stdin (Keyboard) value generated by scanf() to identify if user entered any character, '1' for YES, '0' for NO*/
		/***** Parsing variables ******/
	char *pToken;                 /* Token pointer to be used in parsing command line input string*/
	int tokenCount;               /* Counter used in parsing procedure*/
	char **str[10];               /* Array of strings pointed to by the token*/
	char allocInput[6];
	/*******************************/
	strcpy(userInput, " ");
	strcpy(allocInput, " ");
	fflush(stdin);
	scanf("%[^\n]s", userInput);	/* Accepting user Input*/
	scanf("%c", &temp);		/* Flushing '\n' character from the stdin buffer */
/**************************************** Parsing Start *************************************************/
	tokenCount = 0;
	pToken = strtok(userInput, " ");
	/*Check for an user input*/
	while (!pToken)
	{
		printf("Invalid Input. Please try again: \n");
		fflush(stdin);
		scanf("%[^\n]s", userInput);	/* Accepting user Input*/
		scanf("%c", &temp);		/* Flushing '\n' character from the stdin buffer */
		pToken = strtok(userInput, " ");
	}
	str[0] = &pToken;
	while (pToken != NULL)
	{
		Token[tokenCount] = *str[tokenCount];    /* Saving the parsed texts into *str[] array*/
		pToken = strtok(NULL, " ");
		tokenCount++;
		str[tokenCount] = &pToken;
	}
	/****************************************** Parsing End **************************************************/
	int valid = 0;
	if (strcmp(Token[0], cmds[0]) == 0)             /*     help()     */
	{
		valid = 0;
		help();
		printf("Enter a command: \n");
	}
	else if (strcmp(Token[0], cmds[1]) == 0)      /*     exit()      */
	{
		valid = 1;
		printf("\nGood Bye!\n\n");
	}

	else if (strcmp(Token[0], cmds[2]) == 0)       /*     allocate()    */
	{
		valid = 0;
		if (Token[1]) {
			if (allocStatus == 0)
			{
				memoryOffsetValue = atoi(Token[1]);
				//printf("String to int value = %d", memoryOffsetValue);
				Block_Address = allocate(memoryOffsetValue);
				if (Block_Address)
				{
					printf("\nMemory block allocated.\n");
					printf("Address: %p    size: %d   (%d Bytes)\n", Block_Address, \
						memoryOffsetValue, sizeof(int) * memoryOffsetValue);
					allocStatus = 1;
					/*One memory allocation performed*/
					printf("Enter another command: \n");
				}
			}
			else
			{
				printf("\nMemory is current allocated in address 0x%p\n", Block_Address);
				printf("\nDo you wish to override this data? (Y/N) \n");
				fflush(stdin);
				scanf("%[^\n]s", allocInput);	/* Accepting override Input*/
				scanf("%c", &temp);		/* Flushing '\n' character from the stdin buffer */
				//printf("\nYour answer is: %s \n", allocInput);
				if (strcmp(allocInput, "yes") == 0 || strcmp(allocInput, "YES") == 0 || strcmp(allocInput, "y") == 0 || strcmp(allocInput, "y") == 0)
				{
					free_memory(Block_Address);
					printf(" %d Bytes of heap released from address %p to %p\n", \
					sizeof(int) * memoryOffsetValue, Block_Address, Block_Address + memoryOffsetValue);
					allocStatus = 0;
					/*system ready to allocate memory again*/
					memoryOffsetValue = atoi(Token[1]);
					//printf("String to int value = %d", memoryOffsetValue);
					Block_Address = allocate(memoryOffsetValue);
					if (Block_Address)
					{
						printf("\nMemory block allocated.\n");
						printf("Address: %p    size: %d   (%d Bytes)\n", Block_Address, \
						memoryOffsetValue, sizeof(int) * memoryOffsetValue);
						allocStatus = 1;
						/*One memory allocation performed*/
						printf("Enter another command: \n");
					}
				}
				else
				{
					printf("\nMemory allocated remains in address 0x%p\n", Block_Address);
					printf("Enter another command: \n");

				}
			}
		}
		else 
		{
			printf("No <word> entered, please try again. ");
		}
	}

	else if (strcmp(Token[0], cmds[3]) == 0)        /*    free()    */
	{
		valid = 0;
		if (!Block_Address)
		{
			printf("Memory is not allocated yet!\n");
			printf("Enter another command: \n");
		}
		else
		{
			free_memory(Block_Address);
			printf("%d Bytes of heap released from address %p to %p\n", \
				sizeof(int) * memoryOffsetValue, Block_Address, Block_Address + memoryOffsetValue);
			allocStatus = 0;
			/*system ready to allocate memory again*/
			printf("Enter another command: \n");
		}
	}

	else if (strcmp(Token[0], cmds[4]) == 0)       /*     display()    */
	{
		valid = 0;
		if (Token[1] && Token[2]) 
		{
			int *hexVal = (int*)strtol(Token[1], (char **)NULL, 16);
			//printf("String to int value = 0x%X\n", hexVal);
			memoryOffsetValue = atoi(Token[2]);
			//printf("String to int value = %d\n", memoryOffsetValue);
			display(hexVal, memoryOffsetValue);
			//display(hexVal,Token[2]);
		}

		else 
		{
			
		}
	}
	else if (strcmp(Token[0], cmds[5]) == 0)       /*     write()    */
	{
		valid = 0;
		if (Token[1] && Token[2])
		{
			int hexVal = (int)strtol(Token[1], (char **)NULL, 16);
			printf("String to int value = 0x%X\n", hexVal);
			memoryOffsetValue = atoi(Token[2]);
			printf("String to int value = %d\n", memoryOffsetValue);
			//Block_Address = allocate(memoryOffsetValue);
		}
		else
		{

		}
	}

	else
	{
		valid = 0;
		printf("Invalid input, please try again: \n");
	}

	return valid;
}
/*###################################### inputCheck () End #############################################*/
